theory Protocol3
begin

/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in encryption theories */
//Do not change the following two lines, i.e. do not add, change or remove anything (not even comments) in the following two lines.
functions: f/2
builtins: asymmetric-encryption, symmetric-encryption, hashing 



/* -------------- */
/* Public Key rules */
/* -------------- */

/* The following rule should be annotated by the following action facts: 
- PubKey($A, ~ska)
*/
rule PubKey:  
/*FILL IN HERE*/
    [ Fr(~skA) ]
--[PubKey($A, ~skA)]->
    [ !Ltk($A, ~skA), !Pk($A, pk(~skA)) , Out(pk(~skA))]

/* The following rule should be annotated by the following action facts: 
- RevealKey($A, ~skA)
*/
//un-comment the following line for Task 1.6 // TODO: Make sure function name is correct
rule Reveal_ltk:
  [ !Ltk($A, ~skA) ] --[ Reveal($A),RevealKey($A, ~skA) ]-> [ Out(~skA) ]

/* -------------- */
/* Protocol rules */
/* -------------- */

/* The following rule should be annotated by the following action facts: 
- AliceSendsKey($A, $B, ~skA, pkB, ~Na)
*/
rule AliceSendsKey:
[Fr(~Na), !Ltk($A, ~skA), !Pk($B, pkB)]
--[AliceSendsKey($A, $B, ~skA, pkB, ~Na), Honest($A), Honest($B)]->
[Alice($A,$B, ~Na, ~skA), Out(<$A,aenc(~Na, pkB)>)]

/* The following rule should be annotated by the following action facts: 
- BobReceivesKey($B, $A, ~skB, pkA, ~Nb, Na)
*/
rule BobReceivesKey:
let 
  Kab = f(Na, ~Nb)
in
[Fr(~Nb), In(<$A,aenc(Na, pk(~skB))>) ,!Ltk($B, ~skB), !Pk($A, pkA)]
--[BobReceivesKey($B, $A, ~skB, pkA, ~Nb, Na), Honest($A), Honest($B)]->
[Bob($B, $A, ~Nb, Na, Kab, ~skB), Out(aenc(<~Nb, Kab>,pkA))]


/* The following rule should be annotated by the following action facts: 
- AliceReceivesNb($A, $B, ~skA, ~Na, Nb, ~ma, Kab)
*/
rule AliceReceivesNb:
[Alice($A,$B, ~Na, ~skA), In(aenc(<Nb, Kab>,pk(~skA))), Fr(~ma)]
--[AliceReceivesNb($A, $B, ~skA, ~Na, Nb, ~ma, Kab), Eq(Kab,f(~Na, Nb)),RunningA($A, $B, ~ma), Honest($A), Honest($B)]->
[Out(senc(pair(~ma, h(Nb)), Kab)), Alice2($A,$B,~Na, Kab, ~ma, ~skA)]

/* The following rule should be annotated by the following action facts: 
- BobReceivesMa($B, $A, ~skB, ~Nb, Na, Kab, ~mb, ma)
*/
rule BobReceivesMa:
[Bob($B,$A, ~Nb, Na, Kab, ~skB),Fr(~mb), In(senc(pair(ma, hNb), Kab))]
--[BobReceivesMa($B, $A, ~skB, ~Nb, Na, Kab, ~mb, ma), Eq(h(~Nb),hNb),FinishedB($B,$A,ma,~mb),SecretB(~mb),RunningB($B, $A, ~mb),CommitB($B, $A, ma), Honest($A), Honest($B)]->
[Out(senc(<~mb, h(Na)>, Kab))]

/* The following rule should be annotated by the following action facts: 
- AliceReceivesMb($A, $B, ~skA, ~Na, ~ma, Kab)
*/
rule AliceReceivesMb:
[Alice2($A,$B,~Na, Kab, ~ma, ~skA), In(senc(<mb, hNa>, Kab))]
--[AliceReceivesMb($A, $B, ~skA, ~Na, ~ma, Kab),Eq(h(~Na),hNa),FinishedA($A, $B,  ~ma, mb),SecretA(~ma),CommitA($A, $B, mb), Honest($A), Honest($B)]->
[]

/* Restrictions*/
//You can un-comment these lines if you want to use this restriction to check equality
restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"



/* ---------- */
/* Properties */
/* ---------- */


/* Executability check: */
//Make sure to add the action facts referred to by this lemma in your model
//Do not change this lemma, i.e. do not add, change or remove anything (not even comments) in the following three lines.
lemma executable:
exists-trace "Ex #i #j A B ma mb.
FinishedA(A, B, ma, mb)@i & FinishedB(B,A,ma,mb)@j& not (A=B)"

//un-comment following line for Task 1.3
lemma secrecyA:
  "All n #i. SecretA(n) @i ==> (not (Ex #j. K(n)@j)) | (Ex C #j. Reveal(C)@j & Honest(C)@i)"

//un-comment following line for Task 1.3
lemma secrecyB:
  "All n #i. SecretB(n) @i ==> (not (Ex #j. K(n)@j)) | (Ex C #j. Reveal(C)@j & Honest(C)@i)"

//un-comment following line for Task 1.4
lemma non_injectiveA:
  "All a b t #i. CommitA(a,b,t) @i ==> (Ex #j. RunningB(b,a,t)@j) | (Ex C #r. Reveal(C) @ r & Honest(C) @ i)"

//un-comment following line for Task 1.4
lemma non_injectiveB:
  "All a b t #i. CommitB(b,a,t) @i ==> (Ex #j. RunningA(a,b,t)@j) | (Ex C #r. Reveal(C) @ r & Honest(C) @ i)"

end
