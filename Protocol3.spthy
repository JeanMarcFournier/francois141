theory Protocol3
begin

/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in encryption theories */
//Do not change the following two lines, i.e. do not add, change or remove anything (not even comments) in the following two lines.
functions: f/2
builtins: asymmetric-encryption, symmetric-encryption, hashing



/* -------------- */
/* Public Key rules */
/* -------------- */

/* The following rule should be annotated by the following action facts: 
- PubKey($A, ~ska)
*/ // TODO: Fix it


rule Register_pk:
    [ Fr(~ltk) ]
  -->
    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]


    rule Get_pk:
    [ !Pk($A, pubkey) ]
  -->
    [ Out(pubkey) ]
/* The following rule should be annotated by the following action facts: 
- RevealKey($A, ~skA)
*/
//un-comment the following line for Task 1.6

/* -------------- */
/* Protocol rules */
/* -------------- */

/* The following rule should be annotated by the following action facts: 
- AliceSendsKey($A, $B, ~skA, pkB, ~Na)
*/
rule AliceSendsKey:
[Fr(~Na), !Ltk($A, ~skA), !Pk($B, pkB)]
--[AliceSendsKey($A, $B, ~skA, pkB, ~Na)]->
[Alice($A, ~Na), Out(aenc(~Na, pkB))]

/* The following rule should be annotated by the following action facts: 
- BobReceivesKey($B, $A, ~skB, pkA, ~Nb, Na)
*/
rule BobReceivesKey:
let 
  Kab = f(Na, ~Nb)
in
[Fr(~Nb), In(aenc(Na, pk(~skB))) ,!Ltk($B, ~skB), !Pk($A, pkA)]
--[BobReceivesKey($B, $A, ~skB, pkA, ~Nb, Na)]->
[Bob($A, ~Nb, Na, Kab), Out(aenc(<~Nb, Kab>,pkA))]


/* The following rule should be annotated by the following action facts: 
- 
*/
rule AliceReceivesNb:
[Alice($A, ~Na), In(aenc(<Nb, Kab>,pk(~skA))), Fr(~ma),!Ltk($A, ~skA)]
--[AliceReceivesNb($A, $B, ~skA, ~Na, Nb, ~ma, Kab), Equality(Kab,f(~Na, Nb)),RunningA($A, $B, ~ma)]->
[Out(senc(pair(~ma, h(Nb)), Kab)), Alice2($A,~Na, Kab, ~ma)]

/* The following rule should be annotated by the following action facts: 
- BobReceivesMa($B, $A, ~skB, ~Nb, Na, Kab, ~mb, ma)
*/
rule BobReceivesMa:
[Bob($A, ~Nb, Na, Kab),Fr(~mb), In(senc(pair(ma, hNb), Kab)),!Ltk($B, ~skB)]
--[BobReceivesMa($B, $A, ~skB, ~Nb, Na, Kab, ~mb, ma), Eq(h(~Nb),hNb),FinishedB($B,$A,ma,~mb),RunningB($B, $A, ~mb),SecretB(~mb),CommitB($B, $A, ma)]->
[Out(senc(<~mb, h(Na)>, Kab))]

/* The following rule should be annotated by the following action facts: 
- AliceReceivesMb($A, $B, ~skA, ~Na, ~ma, Kab)
*/
rule AliceReceivesMb:
[Alice2($A,~Na, Kab, ~ma), In(senc(<mb, hNa>, Kab))]
--[Eq(h(~Na),hNa),FinishedA($A, $B,  ~ma, mb),CommitA($A, $B, mb),SecretA(~ma)]->
[]

/* Restrictions*/
//You can un-comment these lines if you want to use this restriction to check equality
restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"



/* ---------- */
/* Properties */
/* ---------- */


/* Executability check: */
//Make sure to add the action facts referred to by this lemma in your model
//Do not change this lemma, i.e. do not add, change or remove anything (not even comments) in the following three lines.
lemma executable:
exists-trace "Ex #i #j A B ma mb.
FinishedA(A, B, ma, mb)@i & FinishedB(B,A,ma,mb)@j& not (A=B)"

//un-comment following line for Task 1.3
lemma secrecyA:
  "All n #i. SecretA(n) @i ==> (not (Ex #j. K(n)@j))"

//un-comment following line for Task 1.3
lemma secrecyB:
  "All n #i. SecretB(n) @i ==> (not (Ex #j. K(n)@j))"

//un-comment following line for Task 1.4
lemma non_injectiveA:
  "All a b t #i. CommitA(a,b,t) @i ==> (Ex #j. RunningB(b,a,t)@j)"

//un-comment following line for Task 1.4
lemma non_injectiveB:
  "All a b t #i. CommitB(b,a,t) @i ==> (Ex #j. RunningA(a,b,t)@j)"

lemma non_injectiveB_correct:
  "All a b t #i. CommitB(b,a,t) @i ==> (Ex c #j. RunningA(a,c,t)@j)"


end
